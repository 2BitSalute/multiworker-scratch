(*
 * Copyright (c) Tatiana Racheva
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

module SharedMem : SharedMem_sig.SHAREDMEM

(** Directly access the shared memory table.

    This can be used to provide proxying across the network *)
module RawAccess : sig
  type serialized = private bytes

  val mem_raw : string -> bool

  val get_raw : string -> serialized option

  val add_raw : string -> serialized -> unit

  val deserialize_raw : serialized -> 'a

  val serialize_raw : 'a -> serialized
end

(** Access the legacy dependency graph *)
module DepTable : sig
  (** Get the number of in-memory dep table entries *)
  val get_in_memory_dep_table_entry_count : unit -> int

  (** Return the filename of the loaded SQLite dep table. Returns None if no
      SQLite dep table was loaded. *)
  val loaded_dep_table_filename : unit -> string option

  (** Save the dep table to an SQLite database.

      Only supports a full init. Will raise an exception if called when
      hh_server was launched with a saved state.

      Returns the number of edges written to the SQLite databse. *)
  val save_dep_table_sqlite : fn:string -> build_revision:string -> int

  (** Save the dep table to a binary blob.

      Will raise an exception if called when hh_server was launched with a
      saved state. This function is only used to support remote workers,
      which have to communicate discovered edges back to the master process.

      If [reset_state_after_saving] is set to true, the in-memory dep table
      will be empied after this operation.

      Returns the number of edges written to the blob.  *)
  val save_dep_table_blob :
    fn:string -> build_revision:string -> reset_state_after_saving:bool -> int

  (** Update the given SQLite database by adding each edge in the dep table
      to it.

      Returns the number of edges written to the SQLite databse. *)
  val update_dep_table_sqlite : fn:string -> build_revision:string -> int

  (** Attach the given SQLite dep table. *)
  val load_dep_table_sqlite : fn:string -> ignore_hh_version:bool -> unit

  (** Load the edges in the given binary blob into the in-memory dep table. *)
  val load_dep_table_blob : fn:string -> ignore_hh_version:bool -> int

  (** Clean up the artifacts generated by SQLite. *)
  val cleanup_sqlite : unit -> unit
end

module MakeGC (SMTelemetry: SharedMem_sig.SMTELEMETRY) : SharedMem_sig.GC

(** A hasher that hashes user-defined keys. The resulting hash can be used
    to index the big shared-memory table.

    Each hash is built by concatenating an optional "old" prefix, a heap-prefix
    and an object-specific key, then hashing the concatenation.

    The unique heap-prefix is automatically generated when calling `MakeKeyHasher`.

    Currently we use MD5 as the hashing algorithm. Note that only the first
    8 bytes are used to index the shared memory table. *)
module type KeyHasher = sig
  (** The type of keys that OCaml-land callers try to insert.

      This key will be object-specific (unique within a heap), but might not be
      unique across heaps. *)
  type key

  (** The hash of an old or new key.

      This hash will be unique across all heaps. *)
  type hash

  val hash : key -> hash

  val hash_old : key -> hash

  (** Return the raw bytes of the digest. Note that this is not hex encoded. *)
  val to_bytes : hash -> string
end

(** The interface that all keys need to implement *)
module type Key = sig
  type t

  val to_string : t -> string

  val compare : t -> t -> int
end

(** Make a new key that can be stored in shared-memory. *)
module MakeKeyHasher (Key : Key) : KeyHasher with type key = Key.t

(** The interface that all values need to implement *)
module type Value = sig
  type t

  val description : string
end

(** Module type for a shared-memory backend for a heap.

    Each backend provided raw access to the underlying shared hash table. *)
module type Backend = functor
  (Core: Core_sig.COREOPS)
  (Measure: Sys_sig.MEASURE)
  (SMTelemetry: SharedMem_sig.SMTELEMETRY)
  (KeyHasher : KeyHasher)
  (Value : Value) -> sig
  val add : KeyHasher.hash -> Value.t -> unit

  val mem : KeyHasher.hash -> bool

  val get : KeyHasher.hash -> Value.t option

  val remove : KeyHasher.hash -> unit

  val move : KeyHasher.hash -> KeyHasher.hash -> unit
end

(** Backend that provides immediate access to the underlying hashtable. *)
module ImmediateBackend : Backend

type 'a profiled_value =
  | RawValue of 'a
  | ProfiledValue of {
      entry: 'a;
      write_time: float;
    }

(** Backend that provides profiled access to the underlying hashtable. *)
module ProfiledBackend : Backend

(** A heap for a user-defined type.

    Each heap supports "old" and "new" values.

    There are several cases where we need to compare the old and the new
    representations of objects to determine what has changed.

    The "old" representation is the value that was bound to that key in
    the last round of type-checking. *)
module type Heap = sig
  type key

  type value

  (** [KeyHasher] created for this heap.

      A new [KeyHasher] with a unique prefix is automatically generated
      for each heap. Normally, you shouldn't have to use the [KeyHasher]
      directly, but Zoncolan does. *)
  module KeyHasher : KeyHasher with type key = key

  module KeySet : Set.S with type elt = key

  module KeyMap : WrappedMap.S with type key = key

  (** Adds a binding to the table.

      Note: TODO(hverr), currently the semantics of inserting a value for a key
      that's already in the heap are unclear and depend on whether you have a
      local-changes stack or not. *)
  val add : key -> value -> unit

  val get : key -> value option

  val get_old : key -> value option

  val get_batch : KeySet.t -> value option KeyMap.t

  val get_old_batch : KeySet.t -> value option KeyMap.t

  val remove : key -> unit

  val remove_old : key -> unit

  val remove_batch : KeySet.t -> unit

  val remove_old_batch : KeySet.t -> unit

  val mem : key -> bool

  val mem_old : key -> bool

  val oldify_batch : KeySet.t -> unit

  val revive_batch : KeySet.t -> unit

  module LocalChanges : sig
    val has_local_changes : unit -> bool

    val push_stack : unit -> unit

    val pop_stack : unit -> unit

    val revert_batch : KeySet.t -> unit

    val commit_batch : KeySet.t -> unit

    val revert_all : unit -> unit

    val commit_all : unit -> unit
  end
end

(** A heap for a user-defined type.

    Provides no worker-local caching. Directly stores to and queries from
    shared memory. *)
module Heap
    (_ : Backend)
    (Core: Core_sig.COREOPS)
    (Measure: Sys_sig.MEASURE)
    (SMTelemetry: SharedMem_sig.SMTELEMETRY)
    (Key : Key)
    (Value : Value) :
  Heap
  with type key = Key.t
   and type value = Value.t
   and module KeyHasher = MakeKeyHasher (Key)
   and module KeySet = Set.Make (Key)
   and module KeyMap = WrappedMap.Make (Core) (Key)

(** A worker-local cache layer.

    Each local cache defines its own eviction strategy.
    For example, we currently have [FreqCache] and [OrderedCache].

    We even have one that combines the two strategies in [MultiCache]. *)
module type LocalCacheLayer = sig
  type key

  type value

  val add : key -> value -> unit

  val get : key -> value option

  val remove : key -> unit

  val clear : unit -> unit

  val get_telemetry_items_and_keys : unit -> Obj.t * key Seq.t
end

(** Invalidate all worker-local caches *)
val invalidate_local_caches : unit -> unit

(** Capacity of a worker-local cache.

    In number of elements. *)
module type Capacity = sig
  val capacity : int
end

(** FreqCache is an LFU (Least Frequently Used) cache.

    It keeps count of how many times each item in the cache has been
    added/replaced/fetched and, when it reaches 2*capacity, then it
    flushes 1*capacity items and they lose their counts. This might result
    in a lucky few early items getting to stay in the cache while newcomers
    get evicted...

    It is Hashtbl.t-based with a bounded number of elements. *)
module FreqCache (Core: Core_sig.COREOPS) (Key : Key) (Value : Value) (_ : Capacity) :
  LocalCacheLayer with type key = Key.t and type value = Value.t

(** OrderedCache is an LRA (Least Recently Added) cache.

    Whenever you add an item beyond capacity, it will evict the oldest one
    to be added.

    It is Hashtbl.t-based with a bounded number of elements. *)
module OrderedCache (Key : Key) (Value : Value) (_ : Capacity) :
  LocalCacheLayer with type key = Key.t and type value = Value.t

(** MultiCache uses both FreqCache and OrderedCache simultaneously.

    It uses both caches with the hope that each one will paper over the
    other's weaknesses. *)
module MultiCache
    (Core: Core_sig.COREOPS)
    (SMTelemetry: SharedMem_sig.SMTELEMETRY)
    (Key : Key)
    (Value : Value)
    (_ : Capacity) :
  LocalCacheLayer with type key = Key.t and type value = Value.t

(** Same as [Heap] but provides a layer of worker-local caching. *)
module HeapWithLocalCache
    (_ : Backend)
    (Core : Core_sig.COREOPS)
    (Measure: Sys_sig.MEASURE)
    (SMTelemetry: SharedMem_sig.SMTELEMETRY)
    (Key : Key)
    (Value : Value)
    (_ : Capacity) : sig
  include
    Heap
    with type key = Key.t
     and type value = Value.t
     and module KeyHasher = MakeKeyHasher (Key)
     and module KeySet = Set.Make (Key)
     and module KeyMap = WrappedMap.Make (Core) (Key)

  val write_around : key -> value -> unit

  val get_no_cache : key -> value option

  module Cache : LocalCacheLayer with type key = key and type value = value
end